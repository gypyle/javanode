1/使用wait和notify实现线程之间的通信
2/生产者和消费者之间的实现
3/方法join的使用
4/ThreadLocal的使用


总结:wait是使线程停止运行,释放共享资源的锁,然后从运行状态退出,进入等待队列,直到在此被唤醒;
     notify是使停止的一个线程继续运行,但是锁不是立即释放,等待notify所在的同步代码块执行完成,才释放锁,并使唤起线程退出等待队列,进入可运行状态;
     wait和notify必须要在同步代码块和同步方法之间运行
     每个锁对象都会有两个队列,一个就绪对列,一个阻塞队列
     线程wait之后调用interrupt方法会报错
     wait(long)等待该时间内线程被其他线程唤醒,超时自动唤醒;
     程序混乱出现的情况:
        过早通知,先执行notify方法,后执行wait方法  解决方法:添加标记
        wait条件发生变化时,发生的操作异常,两个wait同时被唤醒list的remove操作  解决方法:使用循环条件;


     等待通知模式,最经典的案例就是"生产者""消费者"模式 (操作栈解决的是避免只有一个数据,循环条件解决的是异常操作,notifyAll解决的是假死)
        1\一个生产一个消费,不会出现问题
        2\多个生产者和消费者,操作值假死
        3\多生产和多消费,操作值,一般使用notifyAll避免假死这种情况
        4\一生产和一消费,操作栈,保证只有一个数据
        5\一生产多消费,操作栈,解决wait条件改变与假死
        6\多生产一消费,操作栈
        7\多生产与多消费,操作栈,不会出现问题

     connect方法 实现线程之间的管道流通信

     join方法是所属线程执行run方法,而当前线程进行无期限阻塞,等待所属线程结束后,执行当前线程 join方法底部还是使用的wait方法,具有释放锁的特性,所属线程进入等待队列，当前线程阻塞

     ThreadLocal解决变量在不同线程之间的隔离性

