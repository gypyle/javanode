1/synchronized对象监视器为Object时的使用
2/synchronized对象监视器为Class时的使用
3/非线程安全是如何出现的
4/关键字volatile的主要作用
5/关键字volatile与synchronized的区别及使用情况


非线程安全的问题只存在于"实例变量"
synchronized锁的是对象,如果创建多个对象会产生多个锁
两个线程争夺一个对象锁,synchronized方法是同步运行的,非synchronized方法是异步运行的
可重入锁:同一线程可以自动多次获取一个对象锁,否则会很容易产生死锁,同样子父类继承这种情况也是适用的
出现异常锁自动释放
同步不具有继承性,父类的方法是同步的,子类继承的方法可以是非同步的
synchronized同步方法是锁住的整个方法,可以使用synchronized代码块来实现锁住部分代码,实现一半同步,一半异步,提升效率
可以将任意对象作为对象监视器 优点:与其他锁this对象的代码可以异步执行,不需要争抢锁,提升运行效率
这边任意对象监视器里面也可能出现线程非安全问题,可以通过synchronized关键字解决
静态同步synchronized方法和synchronized(class)代码块是给类上锁,与非静态的是给对象上锁,是两把不干扰的锁
静态同步synchronized方法和synchronized(class)代码块的两个对象是同一把锁
任意对象最好不是string类型的,由于string常量池的问题,会导致产生同一把锁
死锁问题的查看,bin目录下执行jps 然后执行jstack -1 线程id
内置类锁:对内置类对象上锁之后,只能以同步的方式访问内置类中的同步方法
对象锁,只要对象不变,即使对象的属性改变,方法还是同步的


什么是jvm的服务器环境

volatile是实现多个变量在线程之间的可见性
synchronized和volatile的比较
1:volatile是线程同步的轻量级实现,只能修饰变量
2:volatile只能保证数据的可见性,并不能保证数据的原子性,synchronized则都能保证
3:volatile多线程访问并不会产生阻塞
4:volatile主要解决的是线程间的可见性,synchronized只要解决的是线程间的访问资源的同步性

volatile在read操作之后的操作,load use asign都不具有原子性,也就是产生线程不安全问题的根源
使用原子类也可能出现线程不安全的情况,因为原子类的方法操作虽然是原子的,但是同时两个原子类方法之间的调用并不是原子的

外练互斥,内修可见
